// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	mm_clientv3 "go.etcd.io/etcd/client/v3"
)

// ETCDTxnMock implements mm_clientv3.Txn
type ETCDTxnMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCommit          func() (tp1 *mm_clientv3.TxnResponse, err error)
	funcCommitOrigin    string
	inspectFuncCommit   func()
	afterCommitCounter  uint64
	beforeCommitCounter uint64
	CommitMock          mETCDTxnMockCommit

	funcElse          func(ops ...mm_clientv3.Op) (t1 mm_clientv3.Txn)
	funcElseOrigin    string
	inspectFuncElse   func(ops ...mm_clientv3.Op)
	afterElseCounter  uint64
	beforeElseCounter uint64
	ElseMock          mETCDTxnMockElse

	funcIf          func(cs ...mm_clientv3.Cmp) (t1 mm_clientv3.Txn)
	funcIfOrigin    string
	inspectFuncIf   func(cs ...mm_clientv3.Cmp)
	afterIfCounter  uint64
	beforeIfCounter uint64
	IfMock          mETCDTxnMockIf

	funcThen          func(ops ...mm_clientv3.Op) (t1 mm_clientv3.Txn)
	funcThenOrigin    string
	inspectFuncThen   func(ops ...mm_clientv3.Op)
	afterThenCounter  uint64
	beforeThenCounter uint64
	ThenMock          mETCDTxnMockThen
}

// NewETCDTxnMock returns a mock for mm_clientv3.Txn
func NewETCDTxnMock(t minimock.Tester) *ETCDTxnMock {
	m := &ETCDTxnMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CommitMock = mETCDTxnMockCommit{mock: m}

	m.ElseMock = mETCDTxnMockElse{mock: m}
	m.ElseMock.callArgs = []*ETCDTxnMockElseParams{}

	m.IfMock = mETCDTxnMockIf{mock: m}
	m.IfMock.callArgs = []*ETCDTxnMockIfParams{}

	m.ThenMock = mETCDTxnMockThen{mock: m}
	m.ThenMock.callArgs = []*ETCDTxnMockThenParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mETCDTxnMockCommit struct {
	optional           bool
	mock               *ETCDTxnMock
	defaultExpectation *ETCDTxnMockCommitExpectation
	expectations       []*ETCDTxnMockCommitExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ETCDTxnMockCommitExpectation specifies expectation struct of the Txn.Commit
type ETCDTxnMockCommitExpectation struct {
	mock *ETCDTxnMock

	results      *ETCDTxnMockCommitResults
	returnOrigin string
	Counter      uint64
}

// ETCDTxnMockCommitResults contains results of the Txn.Commit
type ETCDTxnMockCommitResults struct {
	tp1 *mm_clientv3.TxnResponse
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCommit *mETCDTxnMockCommit) Optional() *mETCDTxnMockCommit {
	mmCommit.optional = true
	return mmCommit
}

// Expect sets up expected params for Txn.Commit
func (mmCommit *mETCDTxnMockCommit) Expect() *mETCDTxnMockCommit {
	if mmCommit.mock.funcCommit != nil {
		mmCommit.mock.t.Fatalf("ETCDTxnMock.Commit mock is already set by Set")
	}

	if mmCommit.defaultExpectation == nil {
		mmCommit.defaultExpectation = &ETCDTxnMockCommitExpectation{}
	}

	return mmCommit
}

// Inspect accepts an inspector function that has same arguments as the Txn.Commit
func (mmCommit *mETCDTxnMockCommit) Inspect(f func()) *mETCDTxnMockCommit {
	if mmCommit.mock.inspectFuncCommit != nil {
		mmCommit.mock.t.Fatalf("Inspect function is already set for ETCDTxnMock.Commit")
	}

	mmCommit.mock.inspectFuncCommit = f

	return mmCommit
}

// Return sets up results that will be returned by Txn.Commit
func (mmCommit *mETCDTxnMockCommit) Return(tp1 *mm_clientv3.TxnResponse, err error) *ETCDTxnMock {
	if mmCommit.mock.funcCommit != nil {
		mmCommit.mock.t.Fatalf("ETCDTxnMock.Commit mock is already set by Set")
	}

	if mmCommit.defaultExpectation == nil {
		mmCommit.defaultExpectation = &ETCDTxnMockCommitExpectation{mock: mmCommit.mock}
	}
	mmCommit.defaultExpectation.results = &ETCDTxnMockCommitResults{tp1, err}
	mmCommit.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCommit.mock
}

// Set uses given function f to mock the Txn.Commit method
func (mmCommit *mETCDTxnMockCommit) Set(f func() (tp1 *mm_clientv3.TxnResponse, err error)) *ETCDTxnMock {
	if mmCommit.defaultExpectation != nil {
		mmCommit.mock.t.Fatalf("Default expectation is already set for the Txn.Commit method")
	}

	if len(mmCommit.expectations) > 0 {
		mmCommit.mock.t.Fatalf("Some expectations are already set for the Txn.Commit method")
	}

	mmCommit.mock.funcCommit = f
	mmCommit.mock.funcCommitOrigin = minimock.CallerInfo(1)
	return mmCommit.mock
}

// Times sets number of times Txn.Commit should be invoked
func (mmCommit *mETCDTxnMockCommit) Times(n uint64) *mETCDTxnMockCommit {
	if n == 0 {
		mmCommit.mock.t.Fatalf("Times of ETCDTxnMock.Commit mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCommit.expectedInvocations, n)
	mmCommit.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCommit
}

func (mmCommit *mETCDTxnMockCommit) invocationsDone() bool {
	if len(mmCommit.expectations) == 0 && mmCommit.defaultExpectation == nil && mmCommit.mock.funcCommit == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCommit.mock.afterCommitCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCommit.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Commit implements mm_clientv3.Txn
func (mmCommit *ETCDTxnMock) Commit() (tp1 *mm_clientv3.TxnResponse, err error) {
	mm_atomic.AddUint64(&mmCommit.beforeCommitCounter, 1)
	defer mm_atomic.AddUint64(&mmCommit.afterCommitCounter, 1)

	mmCommit.t.Helper()

	if mmCommit.inspectFuncCommit != nil {
		mmCommit.inspectFuncCommit()
	}

	if mmCommit.CommitMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCommit.CommitMock.defaultExpectation.Counter, 1)

		mm_results := mmCommit.CommitMock.defaultExpectation.results
		if mm_results == nil {
			mmCommit.t.Fatal("No results are set for the ETCDTxnMock.Commit")
		}
		return (*mm_results).tp1, (*mm_results).err
	}
	if mmCommit.funcCommit != nil {
		return mmCommit.funcCommit()
	}
	mmCommit.t.Fatalf("Unexpected call to ETCDTxnMock.Commit.")
	return
}

// CommitAfterCounter returns a count of finished ETCDTxnMock.Commit invocations
func (mmCommit *ETCDTxnMock) CommitAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommit.afterCommitCounter)
}

// CommitBeforeCounter returns a count of ETCDTxnMock.Commit invocations
func (mmCommit *ETCDTxnMock) CommitBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommit.beforeCommitCounter)
}

// MinimockCommitDone returns true if the count of the Commit invocations corresponds
// the number of defined expectations
func (m *ETCDTxnMock) MinimockCommitDone() bool {
	if m.CommitMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CommitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CommitMock.invocationsDone()
}

// MinimockCommitInspect logs each unmet expectation
func (m *ETCDTxnMock) MinimockCommitInspect() {
	for _, e := range m.CommitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ETCDTxnMock.Commit")
		}
	}

	afterCommitCounter := mm_atomic.LoadUint64(&m.afterCommitCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CommitMock.defaultExpectation != nil && afterCommitCounter < 1 {
		m.t.Errorf("Expected call to ETCDTxnMock.Commit at\n%s", m.CommitMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommit != nil && afterCommitCounter < 1 {
		m.t.Errorf("Expected call to ETCDTxnMock.Commit at\n%s", m.funcCommitOrigin)
	}

	if !m.CommitMock.invocationsDone() && afterCommitCounter > 0 {
		m.t.Errorf("Expected %d calls to ETCDTxnMock.Commit at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CommitMock.expectedInvocations), m.CommitMock.expectedInvocationsOrigin, afterCommitCounter)
	}
}

type mETCDTxnMockElse struct {
	optional           bool
	mock               *ETCDTxnMock
	defaultExpectation *ETCDTxnMockElseExpectation
	expectations       []*ETCDTxnMockElseExpectation

	callArgs []*ETCDTxnMockElseParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ETCDTxnMockElseExpectation specifies expectation struct of the Txn.Else
type ETCDTxnMockElseExpectation struct {
	mock               *ETCDTxnMock
	params             *ETCDTxnMockElseParams
	paramPtrs          *ETCDTxnMockElseParamPtrs
	expectationOrigins ETCDTxnMockElseExpectationOrigins
	results            *ETCDTxnMockElseResults
	returnOrigin       string
	Counter            uint64
}

// ETCDTxnMockElseParams contains parameters of the Txn.Else
type ETCDTxnMockElseParams struct {
	ops []mm_clientv3.Op
}

// ETCDTxnMockElseParamPtrs contains pointers to parameters of the Txn.Else
type ETCDTxnMockElseParamPtrs struct {
	ops *[]mm_clientv3.Op
}

// ETCDTxnMockElseResults contains results of the Txn.Else
type ETCDTxnMockElseResults struct {
	t1 mm_clientv3.Txn
}

// ETCDTxnMockElseOrigins contains origins of expectations of the Txn.Else
type ETCDTxnMockElseExpectationOrigins struct {
	origin    string
	originOps string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmElse *mETCDTxnMockElse) Optional() *mETCDTxnMockElse {
	mmElse.optional = true
	return mmElse
}

// Expect sets up expected params for Txn.Else
func (mmElse *mETCDTxnMockElse) Expect(ops ...mm_clientv3.Op) *mETCDTxnMockElse {
	if mmElse.mock.funcElse != nil {
		mmElse.mock.t.Fatalf("ETCDTxnMock.Else mock is already set by Set")
	}

	if mmElse.defaultExpectation == nil {
		mmElse.defaultExpectation = &ETCDTxnMockElseExpectation{}
	}

	if mmElse.defaultExpectation.paramPtrs != nil {
		mmElse.mock.t.Fatalf("ETCDTxnMock.Else mock is already set by ExpectParams functions")
	}

	mmElse.defaultExpectation.params = &ETCDTxnMockElseParams{ops}
	mmElse.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmElse.expectations {
		if minimock.Equal(e.params, mmElse.defaultExpectation.params) {
			mmElse.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmElse.defaultExpectation.params)
		}
	}

	return mmElse
}

// ExpectOpsParam1 sets up expected param ops for Txn.Else
func (mmElse *mETCDTxnMockElse) ExpectOpsParam1(ops ...mm_clientv3.Op) *mETCDTxnMockElse {
	if mmElse.mock.funcElse != nil {
		mmElse.mock.t.Fatalf("ETCDTxnMock.Else mock is already set by Set")
	}

	if mmElse.defaultExpectation == nil {
		mmElse.defaultExpectation = &ETCDTxnMockElseExpectation{}
	}

	if mmElse.defaultExpectation.params != nil {
		mmElse.mock.t.Fatalf("ETCDTxnMock.Else mock is already set by Expect")
	}

	if mmElse.defaultExpectation.paramPtrs == nil {
		mmElse.defaultExpectation.paramPtrs = &ETCDTxnMockElseParamPtrs{}
	}
	mmElse.defaultExpectation.paramPtrs.ops = &ops
	mmElse.defaultExpectation.expectationOrigins.originOps = minimock.CallerInfo(1)

	return mmElse
}

// Inspect accepts an inspector function that has same arguments as the Txn.Else
func (mmElse *mETCDTxnMockElse) Inspect(f func(ops ...mm_clientv3.Op)) *mETCDTxnMockElse {
	if mmElse.mock.inspectFuncElse != nil {
		mmElse.mock.t.Fatalf("Inspect function is already set for ETCDTxnMock.Else")
	}

	mmElse.mock.inspectFuncElse = f

	return mmElse
}

// Return sets up results that will be returned by Txn.Else
func (mmElse *mETCDTxnMockElse) Return(t1 mm_clientv3.Txn) *ETCDTxnMock {
	if mmElse.mock.funcElse != nil {
		mmElse.mock.t.Fatalf("ETCDTxnMock.Else mock is already set by Set")
	}

	if mmElse.defaultExpectation == nil {
		mmElse.defaultExpectation = &ETCDTxnMockElseExpectation{mock: mmElse.mock}
	}
	mmElse.defaultExpectation.results = &ETCDTxnMockElseResults{t1}
	mmElse.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmElse.mock
}

// Set uses given function f to mock the Txn.Else method
func (mmElse *mETCDTxnMockElse) Set(f func(ops ...mm_clientv3.Op) (t1 mm_clientv3.Txn)) *ETCDTxnMock {
	if mmElse.defaultExpectation != nil {
		mmElse.mock.t.Fatalf("Default expectation is already set for the Txn.Else method")
	}

	if len(mmElse.expectations) > 0 {
		mmElse.mock.t.Fatalf("Some expectations are already set for the Txn.Else method")
	}

	mmElse.mock.funcElse = f
	mmElse.mock.funcElseOrigin = minimock.CallerInfo(1)
	return mmElse.mock
}

// When sets expectation for the Txn.Else which will trigger the result defined by the following
// Then helper
func (mmElse *mETCDTxnMockElse) When(ops ...mm_clientv3.Op) *ETCDTxnMockElseExpectation {
	if mmElse.mock.funcElse != nil {
		mmElse.mock.t.Fatalf("ETCDTxnMock.Else mock is already set by Set")
	}

	expectation := &ETCDTxnMockElseExpectation{
		mock:               mmElse.mock,
		params:             &ETCDTxnMockElseParams{ops},
		expectationOrigins: ETCDTxnMockElseExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmElse.expectations = append(mmElse.expectations, expectation)
	return expectation
}

// Then sets up Txn.Else return parameters for the expectation previously defined by the When method
func (e *ETCDTxnMockElseExpectation) Then(t1 mm_clientv3.Txn) *ETCDTxnMock {
	e.results = &ETCDTxnMockElseResults{t1}
	return e.mock
}

// Times sets number of times Txn.Else should be invoked
func (mmElse *mETCDTxnMockElse) Times(n uint64) *mETCDTxnMockElse {
	if n == 0 {
		mmElse.mock.t.Fatalf("Times of ETCDTxnMock.Else mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmElse.expectedInvocations, n)
	mmElse.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmElse
}

func (mmElse *mETCDTxnMockElse) invocationsDone() bool {
	if len(mmElse.expectations) == 0 && mmElse.defaultExpectation == nil && mmElse.mock.funcElse == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmElse.mock.afterElseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmElse.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Else implements mm_clientv3.Txn
func (mmElse *ETCDTxnMock) Else(ops ...mm_clientv3.Op) (t1 mm_clientv3.Txn) {
	mm_atomic.AddUint64(&mmElse.beforeElseCounter, 1)
	defer mm_atomic.AddUint64(&mmElse.afterElseCounter, 1)

	mmElse.t.Helper()

	if mmElse.inspectFuncElse != nil {
		mmElse.inspectFuncElse(ops...)
	}

	mm_params := ETCDTxnMockElseParams{ops}

	// Record call args
	mmElse.ElseMock.mutex.Lock()
	mmElse.ElseMock.callArgs = append(mmElse.ElseMock.callArgs, &mm_params)
	mmElse.ElseMock.mutex.Unlock()

	for _, e := range mmElse.ElseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.t1
		}
	}

	if mmElse.ElseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmElse.ElseMock.defaultExpectation.Counter, 1)
		mm_want := mmElse.ElseMock.defaultExpectation.params
		mm_want_ptrs := mmElse.ElseMock.defaultExpectation.paramPtrs

		mm_got := ETCDTxnMockElseParams{ops}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ops != nil && !minimock.Equal(*mm_want_ptrs.ops, mm_got.ops) {
				mmElse.t.Errorf("ETCDTxnMock.Else got unexpected parameter ops, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmElse.ElseMock.defaultExpectation.expectationOrigins.originOps, *mm_want_ptrs.ops, mm_got.ops, minimock.Diff(*mm_want_ptrs.ops, mm_got.ops))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmElse.t.Errorf("ETCDTxnMock.Else got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmElse.ElseMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmElse.ElseMock.defaultExpectation.results
		if mm_results == nil {
			mmElse.t.Fatal("No results are set for the ETCDTxnMock.Else")
		}
		return (*mm_results).t1
	}
	if mmElse.funcElse != nil {
		return mmElse.funcElse(ops...)
	}
	mmElse.t.Fatalf("Unexpected call to ETCDTxnMock.Else. %v", ops)
	return
}

// ElseAfterCounter returns a count of finished ETCDTxnMock.Else invocations
func (mmElse *ETCDTxnMock) ElseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmElse.afterElseCounter)
}

// ElseBeforeCounter returns a count of ETCDTxnMock.Else invocations
func (mmElse *ETCDTxnMock) ElseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmElse.beforeElseCounter)
}

// Calls returns a list of arguments used in each call to ETCDTxnMock.Else.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmElse *mETCDTxnMockElse) Calls() []*ETCDTxnMockElseParams {
	mmElse.mutex.RLock()

	argCopy := make([]*ETCDTxnMockElseParams, len(mmElse.callArgs))
	copy(argCopy, mmElse.callArgs)

	mmElse.mutex.RUnlock()

	return argCopy
}

// MinimockElseDone returns true if the count of the Else invocations corresponds
// the number of defined expectations
func (m *ETCDTxnMock) MinimockElseDone() bool {
	if m.ElseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ElseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ElseMock.invocationsDone()
}

// MinimockElseInspect logs each unmet expectation
func (m *ETCDTxnMock) MinimockElseInspect() {
	for _, e := range m.ElseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ETCDTxnMock.Else at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterElseCounter := mm_atomic.LoadUint64(&m.afterElseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ElseMock.defaultExpectation != nil && afterElseCounter < 1 {
		if m.ElseMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ETCDTxnMock.Else at\n%s", m.ElseMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ETCDTxnMock.Else at\n%s with params: %#v", m.ElseMock.defaultExpectation.expectationOrigins.origin, *m.ElseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcElse != nil && afterElseCounter < 1 {
		m.t.Errorf("Expected call to ETCDTxnMock.Else at\n%s", m.funcElseOrigin)
	}

	if !m.ElseMock.invocationsDone() && afterElseCounter > 0 {
		m.t.Errorf("Expected %d calls to ETCDTxnMock.Else at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ElseMock.expectedInvocations), m.ElseMock.expectedInvocationsOrigin, afterElseCounter)
	}
}

type mETCDTxnMockIf struct {
	optional           bool
	mock               *ETCDTxnMock
	defaultExpectation *ETCDTxnMockIfExpectation
	expectations       []*ETCDTxnMockIfExpectation

	callArgs []*ETCDTxnMockIfParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ETCDTxnMockIfExpectation specifies expectation struct of the Txn.If
type ETCDTxnMockIfExpectation struct {
	mock               *ETCDTxnMock
	params             *ETCDTxnMockIfParams
	paramPtrs          *ETCDTxnMockIfParamPtrs
	expectationOrigins ETCDTxnMockIfExpectationOrigins
	results            *ETCDTxnMockIfResults
	returnOrigin       string
	Counter            uint64
}

// ETCDTxnMockIfParams contains parameters of the Txn.If
type ETCDTxnMockIfParams struct {
	cs []mm_clientv3.Cmp
}

// ETCDTxnMockIfParamPtrs contains pointers to parameters of the Txn.If
type ETCDTxnMockIfParamPtrs struct {
	cs *[]mm_clientv3.Cmp
}

// ETCDTxnMockIfResults contains results of the Txn.If
type ETCDTxnMockIfResults struct {
	t1 mm_clientv3.Txn
}

// ETCDTxnMockIfOrigins contains origins of expectations of the Txn.If
type ETCDTxnMockIfExpectationOrigins struct {
	origin   string
	originCs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIf *mETCDTxnMockIf) Optional() *mETCDTxnMockIf {
	mmIf.optional = true
	return mmIf
}

// Expect sets up expected params for Txn.If
func (mmIf *mETCDTxnMockIf) Expect(cs ...mm_clientv3.Cmp) *mETCDTxnMockIf {
	if mmIf.mock.funcIf != nil {
		mmIf.mock.t.Fatalf("ETCDTxnMock.If mock is already set by Set")
	}

	if mmIf.defaultExpectation == nil {
		mmIf.defaultExpectation = &ETCDTxnMockIfExpectation{}
	}

	if mmIf.defaultExpectation.paramPtrs != nil {
		mmIf.mock.t.Fatalf("ETCDTxnMock.If mock is already set by ExpectParams functions")
	}

	mmIf.defaultExpectation.params = &ETCDTxnMockIfParams{cs}
	mmIf.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmIf.expectations {
		if minimock.Equal(e.params, mmIf.defaultExpectation.params) {
			mmIf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIf.defaultExpectation.params)
		}
	}

	return mmIf
}

// ExpectCsParam1 sets up expected param cs for Txn.If
func (mmIf *mETCDTxnMockIf) ExpectCsParam1(cs ...mm_clientv3.Cmp) *mETCDTxnMockIf {
	if mmIf.mock.funcIf != nil {
		mmIf.mock.t.Fatalf("ETCDTxnMock.If mock is already set by Set")
	}

	if mmIf.defaultExpectation == nil {
		mmIf.defaultExpectation = &ETCDTxnMockIfExpectation{}
	}

	if mmIf.defaultExpectation.params != nil {
		mmIf.mock.t.Fatalf("ETCDTxnMock.If mock is already set by Expect")
	}

	if mmIf.defaultExpectation.paramPtrs == nil {
		mmIf.defaultExpectation.paramPtrs = &ETCDTxnMockIfParamPtrs{}
	}
	mmIf.defaultExpectation.paramPtrs.cs = &cs
	mmIf.defaultExpectation.expectationOrigins.originCs = minimock.CallerInfo(1)

	return mmIf
}

// Inspect accepts an inspector function that has same arguments as the Txn.If
func (mmIf *mETCDTxnMockIf) Inspect(f func(cs ...mm_clientv3.Cmp)) *mETCDTxnMockIf {
	if mmIf.mock.inspectFuncIf != nil {
		mmIf.mock.t.Fatalf("Inspect function is already set for ETCDTxnMock.If")
	}

	mmIf.mock.inspectFuncIf = f

	return mmIf
}

// Return sets up results that will be returned by Txn.If
func (mmIf *mETCDTxnMockIf) Return(t1 mm_clientv3.Txn) *ETCDTxnMock {
	if mmIf.mock.funcIf != nil {
		mmIf.mock.t.Fatalf("ETCDTxnMock.If mock is already set by Set")
	}

	if mmIf.defaultExpectation == nil {
		mmIf.defaultExpectation = &ETCDTxnMockIfExpectation{mock: mmIf.mock}
	}
	mmIf.defaultExpectation.results = &ETCDTxnMockIfResults{t1}
	mmIf.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIf.mock
}

// Set uses given function f to mock the Txn.If method
func (mmIf *mETCDTxnMockIf) Set(f func(cs ...mm_clientv3.Cmp) (t1 mm_clientv3.Txn)) *ETCDTxnMock {
	if mmIf.defaultExpectation != nil {
		mmIf.mock.t.Fatalf("Default expectation is already set for the Txn.If method")
	}

	if len(mmIf.expectations) > 0 {
		mmIf.mock.t.Fatalf("Some expectations are already set for the Txn.If method")
	}

	mmIf.mock.funcIf = f
	mmIf.mock.funcIfOrigin = minimock.CallerInfo(1)
	return mmIf.mock
}

// When sets expectation for the Txn.If which will trigger the result defined by the following
// Then helper
func (mmIf *mETCDTxnMockIf) When(cs ...mm_clientv3.Cmp) *ETCDTxnMockIfExpectation {
	if mmIf.mock.funcIf != nil {
		mmIf.mock.t.Fatalf("ETCDTxnMock.If mock is already set by Set")
	}

	expectation := &ETCDTxnMockIfExpectation{
		mock:               mmIf.mock,
		params:             &ETCDTxnMockIfParams{cs},
		expectationOrigins: ETCDTxnMockIfExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmIf.expectations = append(mmIf.expectations, expectation)
	return expectation
}

// Then sets up Txn.If return parameters for the expectation previously defined by the When method
func (e *ETCDTxnMockIfExpectation) Then(t1 mm_clientv3.Txn) *ETCDTxnMock {
	e.results = &ETCDTxnMockIfResults{t1}
	return e.mock
}

// Times sets number of times Txn.If should be invoked
func (mmIf *mETCDTxnMockIf) Times(n uint64) *mETCDTxnMockIf {
	if n == 0 {
		mmIf.mock.t.Fatalf("Times of ETCDTxnMock.If mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIf.expectedInvocations, n)
	mmIf.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIf
}

func (mmIf *mETCDTxnMockIf) invocationsDone() bool {
	if len(mmIf.expectations) == 0 && mmIf.defaultExpectation == nil && mmIf.mock.funcIf == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIf.mock.afterIfCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIf.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// If implements mm_clientv3.Txn
func (mmIf *ETCDTxnMock) If(cs ...mm_clientv3.Cmp) (t1 mm_clientv3.Txn) {
	mm_atomic.AddUint64(&mmIf.beforeIfCounter, 1)
	defer mm_atomic.AddUint64(&mmIf.afterIfCounter, 1)

	mmIf.t.Helper()

	if mmIf.inspectFuncIf != nil {
		mmIf.inspectFuncIf(cs...)
	}

	mm_params := ETCDTxnMockIfParams{cs}

	// Record call args
	mmIf.IfMock.mutex.Lock()
	mmIf.IfMock.callArgs = append(mmIf.IfMock.callArgs, &mm_params)
	mmIf.IfMock.mutex.Unlock()

	for _, e := range mmIf.IfMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.t1
		}
	}

	if mmIf.IfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIf.IfMock.defaultExpectation.Counter, 1)
		mm_want := mmIf.IfMock.defaultExpectation.params
		mm_want_ptrs := mmIf.IfMock.defaultExpectation.paramPtrs

		mm_got := ETCDTxnMockIfParams{cs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.cs != nil && !minimock.Equal(*mm_want_ptrs.cs, mm_got.cs) {
				mmIf.t.Errorf("ETCDTxnMock.If got unexpected parameter cs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIf.IfMock.defaultExpectation.expectationOrigins.originCs, *mm_want_ptrs.cs, mm_got.cs, minimock.Diff(*mm_want_ptrs.cs, mm_got.cs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIf.t.Errorf("ETCDTxnMock.If got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmIf.IfMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIf.IfMock.defaultExpectation.results
		if mm_results == nil {
			mmIf.t.Fatal("No results are set for the ETCDTxnMock.If")
		}
		return (*mm_results).t1
	}
	if mmIf.funcIf != nil {
		return mmIf.funcIf(cs...)
	}
	mmIf.t.Fatalf("Unexpected call to ETCDTxnMock.If. %v", cs)
	return
}

// IfAfterCounter returns a count of finished ETCDTxnMock.If invocations
func (mmIf *ETCDTxnMock) IfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIf.afterIfCounter)
}

// IfBeforeCounter returns a count of ETCDTxnMock.If invocations
func (mmIf *ETCDTxnMock) IfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIf.beforeIfCounter)
}

// Calls returns a list of arguments used in each call to ETCDTxnMock.If.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIf *mETCDTxnMockIf) Calls() []*ETCDTxnMockIfParams {
	mmIf.mutex.RLock()

	argCopy := make([]*ETCDTxnMockIfParams, len(mmIf.callArgs))
	copy(argCopy, mmIf.callArgs)

	mmIf.mutex.RUnlock()

	return argCopy
}

// MinimockIfDone returns true if the count of the If invocations corresponds
// the number of defined expectations
func (m *ETCDTxnMock) MinimockIfDone() bool {
	if m.IfMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IfMock.invocationsDone()
}

// MinimockIfInspect logs each unmet expectation
func (m *ETCDTxnMock) MinimockIfInspect() {
	for _, e := range m.IfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ETCDTxnMock.If at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterIfCounter := mm_atomic.LoadUint64(&m.afterIfCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IfMock.defaultExpectation != nil && afterIfCounter < 1 {
		if m.IfMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ETCDTxnMock.If at\n%s", m.IfMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ETCDTxnMock.If at\n%s with params: %#v", m.IfMock.defaultExpectation.expectationOrigins.origin, *m.IfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIf != nil && afterIfCounter < 1 {
		m.t.Errorf("Expected call to ETCDTxnMock.If at\n%s", m.funcIfOrigin)
	}

	if !m.IfMock.invocationsDone() && afterIfCounter > 0 {
		m.t.Errorf("Expected %d calls to ETCDTxnMock.If at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IfMock.expectedInvocations), m.IfMock.expectedInvocationsOrigin, afterIfCounter)
	}
}

type mETCDTxnMockThen struct {
	optional           bool
	mock               *ETCDTxnMock
	defaultExpectation *ETCDTxnMockThenExpectation
	expectations       []*ETCDTxnMockThenExpectation

	callArgs []*ETCDTxnMockThenParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ETCDTxnMockThenExpectation specifies expectation struct of the Txn.Then
type ETCDTxnMockThenExpectation struct {
	mock               *ETCDTxnMock
	params             *ETCDTxnMockThenParams
	paramPtrs          *ETCDTxnMockThenParamPtrs
	expectationOrigins ETCDTxnMockThenExpectationOrigins
	results            *ETCDTxnMockThenResults
	returnOrigin       string
	Counter            uint64
}

// ETCDTxnMockThenParams contains parameters of the Txn.Then
type ETCDTxnMockThenParams struct {
	ops []mm_clientv3.Op
}

// ETCDTxnMockThenParamPtrs contains pointers to parameters of the Txn.Then
type ETCDTxnMockThenParamPtrs struct {
	ops *[]mm_clientv3.Op
}

// ETCDTxnMockThenResults contains results of the Txn.Then
type ETCDTxnMockThenResults struct {
	t1 mm_clientv3.Txn
}

// ETCDTxnMockThenOrigins contains origins of expectations of the Txn.Then
type ETCDTxnMockThenExpectationOrigins struct {
	origin    string
	originOps string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmThen *mETCDTxnMockThen) Optional() *mETCDTxnMockThen {
	mmThen.optional = true
	return mmThen
}

// Expect sets up expected params for Txn.Then
func (mmThen *mETCDTxnMockThen) Expect(ops ...mm_clientv3.Op) *mETCDTxnMockThen {
	if mmThen.mock.funcThen != nil {
		mmThen.mock.t.Fatalf("ETCDTxnMock.Then mock is already set by Set")
	}

	if mmThen.defaultExpectation == nil {
		mmThen.defaultExpectation = &ETCDTxnMockThenExpectation{}
	}

	if mmThen.defaultExpectation.paramPtrs != nil {
		mmThen.mock.t.Fatalf("ETCDTxnMock.Then mock is already set by ExpectParams functions")
	}

	mmThen.defaultExpectation.params = &ETCDTxnMockThenParams{ops}
	mmThen.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmThen.expectations {
		if minimock.Equal(e.params, mmThen.defaultExpectation.params) {
			mmThen.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmThen.defaultExpectation.params)
		}
	}

	return mmThen
}

// ExpectOpsParam1 sets up expected param ops for Txn.Then
func (mmThen *mETCDTxnMockThen) ExpectOpsParam1(ops ...mm_clientv3.Op) *mETCDTxnMockThen {
	if mmThen.mock.funcThen != nil {
		mmThen.mock.t.Fatalf("ETCDTxnMock.Then mock is already set by Set")
	}

	if mmThen.defaultExpectation == nil {
		mmThen.defaultExpectation = &ETCDTxnMockThenExpectation{}
	}

	if mmThen.defaultExpectation.params != nil {
		mmThen.mock.t.Fatalf("ETCDTxnMock.Then mock is already set by Expect")
	}

	if mmThen.defaultExpectation.paramPtrs == nil {
		mmThen.defaultExpectation.paramPtrs = &ETCDTxnMockThenParamPtrs{}
	}
	mmThen.defaultExpectation.paramPtrs.ops = &ops
	mmThen.defaultExpectation.expectationOrigins.originOps = minimock.CallerInfo(1)

	return mmThen
}

// Inspect accepts an inspector function that has same arguments as the Txn.Then
func (mmThen *mETCDTxnMockThen) Inspect(f func(ops ...mm_clientv3.Op)) *mETCDTxnMockThen {
	if mmThen.mock.inspectFuncThen != nil {
		mmThen.mock.t.Fatalf("Inspect function is already set for ETCDTxnMock.Then")
	}

	mmThen.mock.inspectFuncThen = f

	return mmThen
}

// Return sets up results that will be returned by Txn.Then
func (mmThen *mETCDTxnMockThen) Return(t1 mm_clientv3.Txn) *ETCDTxnMock {
	if mmThen.mock.funcThen != nil {
		mmThen.mock.t.Fatalf("ETCDTxnMock.Then mock is already set by Set")
	}

	if mmThen.defaultExpectation == nil {
		mmThen.defaultExpectation = &ETCDTxnMockThenExpectation{mock: mmThen.mock}
	}
	mmThen.defaultExpectation.results = &ETCDTxnMockThenResults{t1}
	mmThen.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmThen.mock
}

// Set uses given function f to mock the Txn.Then method
func (mmThen *mETCDTxnMockThen) Set(f func(ops ...mm_clientv3.Op) (t1 mm_clientv3.Txn)) *ETCDTxnMock {
	if mmThen.defaultExpectation != nil {
		mmThen.mock.t.Fatalf("Default expectation is already set for the Txn.Then method")
	}

	if len(mmThen.expectations) > 0 {
		mmThen.mock.t.Fatalf("Some expectations are already set for the Txn.Then method")
	}

	mmThen.mock.funcThen = f
	mmThen.mock.funcThenOrigin = minimock.CallerInfo(1)
	return mmThen.mock
}

// When sets expectation for the Txn.Then which will trigger the result defined by the following
// Then helper
func (mmThen *mETCDTxnMockThen) When(ops ...mm_clientv3.Op) *ETCDTxnMockThenExpectation {
	if mmThen.mock.funcThen != nil {
		mmThen.mock.t.Fatalf("ETCDTxnMock.Then mock is already set by Set")
	}

	expectation := &ETCDTxnMockThenExpectation{
		mock:               mmThen.mock,
		params:             &ETCDTxnMockThenParams{ops},
		expectationOrigins: ETCDTxnMockThenExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmThen.expectations = append(mmThen.expectations, expectation)
	return expectation
}

// Then sets up Txn.Then return parameters for the expectation previously defined by the When method
func (e *ETCDTxnMockThenExpectation) Then(t1 mm_clientv3.Txn) *ETCDTxnMock {
	e.results = &ETCDTxnMockThenResults{t1}
	return e.mock
}

// Times sets number of times Txn.Then should be invoked
func (mmThen *mETCDTxnMockThen) Times(n uint64) *mETCDTxnMockThen {
	if n == 0 {
		mmThen.mock.t.Fatalf("Times of ETCDTxnMock.Then mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmThen.expectedInvocations, n)
	mmThen.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmThen
}

func (mmThen *mETCDTxnMockThen) invocationsDone() bool {
	if len(mmThen.expectations) == 0 && mmThen.defaultExpectation == nil && mmThen.mock.funcThen == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmThen.mock.afterThenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmThen.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Then implements mm_clientv3.Txn
func (mmThen *ETCDTxnMock) Then(ops ...mm_clientv3.Op) (t1 mm_clientv3.Txn) {
	mm_atomic.AddUint64(&mmThen.beforeThenCounter, 1)
	defer mm_atomic.AddUint64(&mmThen.afterThenCounter, 1)

	mmThen.t.Helper()

	if mmThen.inspectFuncThen != nil {
		mmThen.inspectFuncThen(ops...)
	}

	mm_params := ETCDTxnMockThenParams{ops}

	// Record call args
	mmThen.ThenMock.mutex.Lock()
	mmThen.ThenMock.callArgs = append(mmThen.ThenMock.callArgs, &mm_params)
	mmThen.ThenMock.mutex.Unlock()

	for _, e := range mmThen.ThenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.t1
		}
	}

	if mmThen.ThenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmThen.ThenMock.defaultExpectation.Counter, 1)
		mm_want := mmThen.ThenMock.defaultExpectation.params
		mm_want_ptrs := mmThen.ThenMock.defaultExpectation.paramPtrs

		mm_got := ETCDTxnMockThenParams{ops}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ops != nil && !minimock.Equal(*mm_want_ptrs.ops, mm_got.ops) {
				mmThen.t.Errorf("ETCDTxnMock.Then got unexpected parameter ops, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmThen.ThenMock.defaultExpectation.expectationOrigins.originOps, *mm_want_ptrs.ops, mm_got.ops, minimock.Diff(*mm_want_ptrs.ops, mm_got.ops))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmThen.t.Errorf("ETCDTxnMock.Then got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmThen.ThenMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmThen.ThenMock.defaultExpectation.results
		if mm_results == nil {
			mmThen.t.Fatal("No results are set for the ETCDTxnMock.Then")
		}
		return (*mm_results).t1
	}
	if mmThen.funcThen != nil {
		return mmThen.funcThen(ops...)
	}
	mmThen.t.Fatalf("Unexpected call to ETCDTxnMock.Then. %v", ops)
	return
}

// ThenAfterCounter returns a count of finished ETCDTxnMock.Then invocations
func (mmThen *ETCDTxnMock) ThenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmThen.afterThenCounter)
}

// ThenBeforeCounter returns a count of ETCDTxnMock.Then invocations
func (mmThen *ETCDTxnMock) ThenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmThen.beforeThenCounter)
}

// Calls returns a list of arguments used in each call to ETCDTxnMock.Then.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmThen *mETCDTxnMockThen) Calls() []*ETCDTxnMockThenParams {
	mmThen.mutex.RLock()

	argCopy := make([]*ETCDTxnMockThenParams, len(mmThen.callArgs))
	copy(argCopy, mmThen.callArgs)

	mmThen.mutex.RUnlock()

	return argCopy
}

// MinimockThenDone returns true if the count of the Then invocations corresponds
// the number of defined expectations
func (m *ETCDTxnMock) MinimockThenDone() bool {
	if m.ThenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ThenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ThenMock.invocationsDone()
}

// MinimockThenInspect logs each unmet expectation
func (m *ETCDTxnMock) MinimockThenInspect() {
	for _, e := range m.ThenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ETCDTxnMock.Then at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterThenCounter := mm_atomic.LoadUint64(&m.afterThenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ThenMock.defaultExpectation != nil && afterThenCounter < 1 {
		if m.ThenMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ETCDTxnMock.Then at\n%s", m.ThenMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ETCDTxnMock.Then at\n%s with params: %#v", m.ThenMock.defaultExpectation.expectationOrigins.origin, *m.ThenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcThen != nil && afterThenCounter < 1 {
		m.t.Errorf("Expected call to ETCDTxnMock.Then at\n%s", m.funcThenOrigin)
	}

	if !m.ThenMock.invocationsDone() && afterThenCounter > 0 {
		m.t.Errorf("Expected %d calls to ETCDTxnMock.Then at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ThenMock.expectedInvocations), m.ThenMock.expectedInvocationsOrigin, afterThenCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ETCDTxnMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCommitInspect()

			m.MinimockElseInspect()

			m.MinimockIfInspect()

			m.MinimockThenInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ETCDTxnMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ETCDTxnMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCommitDone() &&
		m.MinimockElseDone() &&
		m.MinimockIfDone() &&
		m.MinimockThenDone()
}
