// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/tarantool/go-tarantool/v2"
)

// DoerWatcherMock implements mm_tcs.DoerWatcher
type DoerWatcherMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDo          func(req tarantool.Request) (fut *tarantool.Future)
	funcDoOrigin    string
	inspectFuncDo   func(req tarantool.Request)
	afterDoCounter  uint64
	beforeDoCounter uint64
	DoMock          mDoerWatcherMockDo

	funcNewWatcher          func(key string, callback tarantool.WatchCallback) (w1 tarantool.Watcher, err error)
	funcNewWatcherOrigin    string
	inspectFuncNewWatcher   func(key string, callback tarantool.WatchCallback)
	afterNewWatcherCounter  uint64
	beforeNewWatcherCounter uint64
	NewWatcherMock          mDoerWatcherMockNewWatcher
}

// NewDoerWatcherMock returns a mock for mm_tcs.DoerWatcher
func NewDoerWatcherMock(t minimock.Tester) *DoerWatcherMock {
	m := &DoerWatcherMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DoMock = mDoerWatcherMockDo{mock: m}
	m.DoMock.callArgs = []*DoerWatcherMockDoParams{}

	m.NewWatcherMock = mDoerWatcherMockNewWatcher{mock: m}
	m.NewWatcherMock.callArgs = []*DoerWatcherMockNewWatcherParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mDoerWatcherMockDo struct {
	optional           bool
	mock               *DoerWatcherMock
	defaultExpectation *DoerWatcherMockDoExpectation
	expectations       []*DoerWatcherMockDoExpectation

	callArgs []*DoerWatcherMockDoParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DoerWatcherMockDoExpectation specifies expectation struct of the DoerWatcher.Do
type DoerWatcherMockDoExpectation struct {
	mock               *DoerWatcherMock
	params             *DoerWatcherMockDoParams
	paramPtrs          *DoerWatcherMockDoParamPtrs
	expectationOrigins DoerWatcherMockDoExpectationOrigins
	results            *DoerWatcherMockDoResults
	returnOrigin       string
	Counter            uint64
}

// DoerWatcherMockDoParams contains parameters of the DoerWatcher.Do
type DoerWatcherMockDoParams struct {
	req tarantool.Request
}

// DoerWatcherMockDoParamPtrs contains pointers to parameters of the DoerWatcher.Do
type DoerWatcherMockDoParamPtrs struct {
	req *tarantool.Request
}

// DoerWatcherMockDoResults contains results of the DoerWatcher.Do
type DoerWatcherMockDoResults struct {
	fut *tarantool.Future
}

// DoerWatcherMockDoOrigins contains origins of expectations of the DoerWatcher.Do
type DoerWatcherMockDoExpectationOrigins struct {
	origin    string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDo *mDoerWatcherMockDo) Optional() *mDoerWatcherMockDo {
	mmDo.optional = true
	return mmDo
}

// Expect sets up expected params for DoerWatcher.Do
func (mmDo *mDoerWatcherMockDo) Expect(req tarantool.Request) *mDoerWatcherMockDo {
	if mmDo.mock.funcDo != nil {
		mmDo.mock.t.Fatalf("DoerWatcherMock.Do mock is already set by Set")
	}

	if mmDo.defaultExpectation == nil {
		mmDo.defaultExpectation = &DoerWatcherMockDoExpectation{}
	}

	if mmDo.defaultExpectation.paramPtrs != nil {
		mmDo.mock.t.Fatalf("DoerWatcherMock.Do mock is already set by ExpectParams functions")
	}

	mmDo.defaultExpectation.params = &DoerWatcherMockDoParams{req}
	mmDo.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDo.expectations {
		if minimock.Equal(e.params, mmDo.defaultExpectation.params) {
			mmDo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDo.defaultExpectation.params)
		}
	}

	return mmDo
}

// ExpectReqParam1 sets up expected param req for DoerWatcher.Do
func (mmDo *mDoerWatcherMockDo) ExpectReqParam1(req tarantool.Request) *mDoerWatcherMockDo {
	if mmDo.mock.funcDo != nil {
		mmDo.mock.t.Fatalf("DoerWatcherMock.Do mock is already set by Set")
	}

	if mmDo.defaultExpectation == nil {
		mmDo.defaultExpectation = &DoerWatcherMockDoExpectation{}
	}

	if mmDo.defaultExpectation.params != nil {
		mmDo.mock.t.Fatalf("DoerWatcherMock.Do mock is already set by Expect")
	}

	if mmDo.defaultExpectation.paramPtrs == nil {
		mmDo.defaultExpectation.paramPtrs = &DoerWatcherMockDoParamPtrs{}
	}
	mmDo.defaultExpectation.paramPtrs.req = &req
	mmDo.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmDo
}

// Inspect accepts an inspector function that has same arguments as the DoerWatcher.Do
func (mmDo *mDoerWatcherMockDo) Inspect(f func(req tarantool.Request)) *mDoerWatcherMockDo {
	if mmDo.mock.inspectFuncDo != nil {
		mmDo.mock.t.Fatalf("Inspect function is already set for DoerWatcherMock.Do")
	}

	mmDo.mock.inspectFuncDo = f

	return mmDo
}

// Return sets up results that will be returned by DoerWatcher.Do
func (mmDo *mDoerWatcherMockDo) Return(fut *tarantool.Future) *DoerWatcherMock {
	if mmDo.mock.funcDo != nil {
		mmDo.mock.t.Fatalf("DoerWatcherMock.Do mock is already set by Set")
	}

	if mmDo.defaultExpectation == nil {
		mmDo.defaultExpectation = &DoerWatcherMockDoExpectation{mock: mmDo.mock}
	}
	mmDo.defaultExpectation.results = &DoerWatcherMockDoResults{fut}
	mmDo.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDo.mock
}

// Set uses given function f to mock the DoerWatcher.Do method
func (mmDo *mDoerWatcherMockDo) Set(f func(req tarantool.Request) (fut *tarantool.Future)) *DoerWatcherMock {
	if mmDo.defaultExpectation != nil {
		mmDo.mock.t.Fatalf("Default expectation is already set for the DoerWatcher.Do method")
	}

	if len(mmDo.expectations) > 0 {
		mmDo.mock.t.Fatalf("Some expectations are already set for the DoerWatcher.Do method")
	}

	mmDo.mock.funcDo = f
	mmDo.mock.funcDoOrigin = minimock.CallerInfo(1)
	return mmDo.mock
}

// When sets expectation for the DoerWatcher.Do which will trigger the result defined by the following
// Then helper
func (mmDo *mDoerWatcherMockDo) When(req tarantool.Request) *DoerWatcherMockDoExpectation {
	if mmDo.mock.funcDo != nil {
		mmDo.mock.t.Fatalf("DoerWatcherMock.Do mock is already set by Set")
	}

	expectation := &DoerWatcherMockDoExpectation{
		mock:               mmDo.mock,
		params:             &DoerWatcherMockDoParams{req},
		expectationOrigins: DoerWatcherMockDoExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDo.expectations = append(mmDo.expectations, expectation)
	return expectation
}

// Then sets up DoerWatcher.Do return parameters for the expectation previously defined by the When method
func (e *DoerWatcherMockDoExpectation) Then(fut *tarantool.Future) *DoerWatcherMock {
	e.results = &DoerWatcherMockDoResults{fut}
	return e.mock
}

// Times sets number of times DoerWatcher.Do should be invoked
func (mmDo *mDoerWatcherMockDo) Times(n uint64) *mDoerWatcherMockDo {
	if n == 0 {
		mmDo.mock.t.Fatalf("Times of DoerWatcherMock.Do mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDo.expectedInvocations, n)
	mmDo.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDo
}

func (mmDo *mDoerWatcherMockDo) invocationsDone() bool {
	if len(mmDo.expectations) == 0 && mmDo.defaultExpectation == nil && mmDo.mock.funcDo == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDo.mock.afterDoCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDo.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Do implements mm_tcs.DoerWatcher
func (mmDo *DoerWatcherMock) Do(req tarantool.Request) (fut *tarantool.Future) {
	mm_atomic.AddUint64(&mmDo.beforeDoCounter, 1)
	defer mm_atomic.AddUint64(&mmDo.afterDoCounter, 1)

	mmDo.t.Helper()

	if mmDo.inspectFuncDo != nil {
		mmDo.inspectFuncDo(req)
	}

	mm_params := DoerWatcherMockDoParams{req}

	// Record call args
	mmDo.DoMock.mutex.Lock()
	mmDo.DoMock.callArgs = append(mmDo.DoMock.callArgs, &mm_params)
	mmDo.DoMock.mutex.Unlock()

	for _, e := range mmDo.DoMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.fut
		}
	}

	if mmDo.DoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDo.DoMock.defaultExpectation.Counter, 1)
		mm_want := mmDo.DoMock.defaultExpectation.params
		mm_want_ptrs := mmDo.DoMock.defaultExpectation.paramPtrs

		mm_got := DoerWatcherMockDoParams{req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmDo.t.Errorf("DoerWatcherMock.Do got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDo.DoMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDo.t.Errorf("DoerWatcherMock.Do got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDo.DoMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDo.DoMock.defaultExpectation.results
		if mm_results == nil {
			mmDo.t.Fatal("No results are set for the DoerWatcherMock.Do")
		}
		return (*mm_results).fut
	}
	if mmDo.funcDo != nil {
		return mmDo.funcDo(req)
	}
	mmDo.t.Fatalf("Unexpected call to DoerWatcherMock.Do. %v", req)
	return
}

// DoAfterCounter returns a count of finished DoerWatcherMock.Do invocations
func (mmDo *DoerWatcherMock) DoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDo.afterDoCounter)
}

// DoBeforeCounter returns a count of DoerWatcherMock.Do invocations
func (mmDo *DoerWatcherMock) DoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDo.beforeDoCounter)
}

// Calls returns a list of arguments used in each call to DoerWatcherMock.Do.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDo *mDoerWatcherMockDo) Calls() []*DoerWatcherMockDoParams {
	mmDo.mutex.RLock()

	argCopy := make([]*DoerWatcherMockDoParams, len(mmDo.callArgs))
	copy(argCopy, mmDo.callArgs)

	mmDo.mutex.RUnlock()

	return argCopy
}

// MinimockDoDone returns true if the count of the Do invocations corresponds
// the number of defined expectations
func (m *DoerWatcherMock) MinimockDoDone() bool {
	if m.DoMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DoMock.invocationsDone()
}

// MinimockDoInspect logs each unmet expectation
func (m *DoerWatcherMock) MinimockDoInspect() {
	for _, e := range m.DoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DoerWatcherMock.Do at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDoCounter := mm_atomic.LoadUint64(&m.afterDoCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DoMock.defaultExpectation != nil && afterDoCounter < 1 {
		if m.DoMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DoerWatcherMock.Do at\n%s", m.DoMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DoerWatcherMock.Do at\n%s with params: %#v", m.DoMock.defaultExpectation.expectationOrigins.origin, *m.DoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDo != nil && afterDoCounter < 1 {
		m.t.Errorf("Expected call to DoerWatcherMock.Do at\n%s", m.funcDoOrigin)
	}

	if !m.DoMock.invocationsDone() && afterDoCounter > 0 {
		m.t.Errorf("Expected %d calls to DoerWatcherMock.Do at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DoMock.expectedInvocations), m.DoMock.expectedInvocationsOrigin, afterDoCounter)
	}
}

type mDoerWatcherMockNewWatcher struct {
	optional           bool
	mock               *DoerWatcherMock
	defaultExpectation *DoerWatcherMockNewWatcherExpectation
	expectations       []*DoerWatcherMockNewWatcherExpectation

	callArgs []*DoerWatcherMockNewWatcherParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DoerWatcherMockNewWatcherExpectation specifies expectation struct of the DoerWatcher.NewWatcher
type DoerWatcherMockNewWatcherExpectation struct {
	mock               *DoerWatcherMock
	params             *DoerWatcherMockNewWatcherParams
	paramPtrs          *DoerWatcherMockNewWatcherParamPtrs
	expectationOrigins DoerWatcherMockNewWatcherExpectationOrigins
	results            *DoerWatcherMockNewWatcherResults
	returnOrigin       string
	Counter            uint64
}

// DoerWatcherMockNewWatcherParams contains parameters of the DoerWatcher.NewWatcher
type DoerWatcherMockNewWatcherParams struct {
	key      string
	callback tarantool.WatchCallback
}

// DoerWatcherMockNewWatcherParamPtrs contains pointers to parameters of the DoerWatcher.NewWatcher
type DoerWatcherMockNewWatcherParamPtrs struct {
	key      *string
	callback *tarantool.WatchCallback
}

// DoerWatcherMockNewWatcherResults contains results of the DoerWatcher.NewWatcher
type DoerWatcherMockNewWatcherResults struct {
	w1  tarantool.Watcher
	err error
}

// DoerWatcherMockNewWatcherOrigins contains origins of expectations of the DoerWatcher.NewWatcher
type DoerWatcherMockNewWatcherExpectationOrigins struct {
	origin         string
	originKey      string
	originCallback string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmNewWatcher *mDoerWatcherMockNewWatcher) Optional() *mDoerWatcherMockNewWatcher {
	mmNewWatcher.optional = true
	return mmNewWatcher
}

// Expect sets up expected params for DoerWatcher.NewWatcher
func (mmNewWatcher *mDoerWatcherMockNewWatcher) Expect(key string, callback tarantool.WatchCallback) *mDoerWatcherMockNewWatcher {
	if mmNewWatcher.mock.funcNewWatcher != nil {
		mmNewWatcher.mock.t.Fatalf("DoerWatcherMock.NewWatcher mock is already set by Set")
	}

	if mmNewWatcher.defaultExpectation == nil {
		mmNewWatcher.defaultExpectation = &DoerWatcherMockNewWatcherExpectation{}
	}

	if mmNewWatcher.defaultExpectation.paramPtrs != nil {
		mmNewWatcher.mock.t.Fatalf("DoerWatcherMock.NewWatcher mock is already set by ExpectParams functions")
	}

	mmNewWatcher.defaultExpectation.params = &DoerWatcherMockNewWatcherParams{key, callback}
	mmNewWatcher.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmNewWatcher.expectations {
		if minimock.Equal(e.params, mmNewWatcher.defaultExpectation.params) {
			mmNewWatcher.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmNewWatcher.defaultExpectation.params)
		}
	}

	return mmNewWatcher
}

// ExpectKeyParam1 sets up expected param key for DoerWatcher.NewWatcher
func (mmNewWatcher *mDoerWatcherMockNewWatcher) ExpectKeyParam1(key string) *mDoerWatcherMockNewWatcher {
	if mmNewWatcher.mock.funcNewWatcher != nil {
		mmNewWatcher.mock.t.Fatalf("DoerWatcherMock.NewWatcher mock is already set by Set")
	}

	if mmNewWatcher.defaultExpectation == nil {
		mmNewWatcher.defaultExpectation = &DoerWatcherMockNewWatcherExpectation{}
	}

	if mmNewWatcher.defaultExpectation.params != nil {
		mmNewWatcher.mock.t.Fatalf("DoerWatcherMock.NewWatcher mock is already set by Expect")
	}

	if mmNewWatcher.defaultExpectation.paramPtrs == nil {
		mmNewWatcher.defaultExpectation.paramPtrs = &DoerWatcherMockNewWatcherParamPtrs{}
	}
	mmNewWatcher.defaultExpectation.paramPtrs.key = &key
	mmNewWatcher.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmNewWatcher
}

// ExpectCallbackParam2 sets up expected param callback for DoerWatcher.NewWatcher
func (mmNewWatcher *mDoerWatcherMockNewWatcher) ExpectCallbackParam2(callback tarantool.WatchCallback) *mDoerWatcherMockNewWatcher {
	if mmNewWatcher.mock.funcNewWatcher != nil {
		mmNewWatcher.mock.t.Fatalf("DoerWatcherMock.NewWatcher mock is already set by Set")
	}

	if mmNewWatcher.defaultExpectation == nil {
		mmNewWatcher.defaultExpectation = &DoerWatcherMockNewWatcherExpectation{}
	}

	if mmNewWatcher.defaultExpectation.params != nil {
		mmNewWatcher.mock.t.Fatalf("DoerWatcherMock.NewWatcher mock is already set by Expect")
	}

	if mmNewWatcher.defaultExpectation.paramPtrs == nil {
		mmNewWatcher.defaultExpectation.paramPtrs = &DoerWatcherMockNewWatcherParamPtrs{}
	}
	mmNewWatcher.defaultExpectation.paramPtrs.callback = &callback
	mmNewWatcher.defaultExpectation.expectationOrigins.originCallback = minimock.CallerInfo(1)

	return mmNewWatcher
}

// Inspect accepts an inspector function that has same arguments as the DoerWatcher.NewWatcher
func (mmNewWatcher *mDoerWatcherMockNewWatcher) Inspect(f func(key string, callback tarantool.WatchCallback)) *mDoerWatcherMockNewWatcher {
	if mmNewWatcher.mock.inspectFuncNewWatcher != nil {
		mmNewWatcher.mock.t.Fatalf("Inspect function is already set for DoerWatcherMock.NewWatcher")
	}

	mmNewWatcher.mock.inspectFuncNewWatcher = f

	return mmNewWatcher
}

// Return sets up results that will be returned by DoerWatcher.NewWatcher
func (mmNewWatcher *mDoerWatcherMockNewWatcher) Return(w1 tarantool.Watcher, err error) *DoerWatcherMock {
	if mmNewWatcher.mock.funcNewWatcher != nil {
		mmNewWatcher.mock.t.Fatalf("DoerWatcherMock.NewWatcher mock is already set by Set")
	}

	if mmNewWatcher.defaultExpectation == nil {
		mmNewWatcher.defaultExpectation = &DoerWatcherMockNewWatcherExpectation{mock: mmNewWatcher.mock}
	}
	mmNewWatcher.defaultExpectation.results = &DoerWatcherMockNewWatcherResults{w1, err}
	mmNewWatcher.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmNewWatcher.mock
}

// Set uses given function f to mock the DoerWatcher.NewWatcher method
func (mmNewWatcher *mDoerWatcherMockNewWatcher) Set(f func(key string, callback tarantool.WatchCallback) (w1 tarantool.Watcher, err error)) *DoerWatcherMock {
	if mmNewWatcher.defaultExpectation != nil {
		mmNewWatcher.mock.t.Fatalf("Default expectation is already set for the DoerWatcher.NewWatcher method")
	}

	if len(mmNewWatcher.expectations) > 0 {
		mmNewWatcher.mock.t.Fatalf("Some expectations are already set for the DoerWatcher.NewWatcher method")
	}

	mmNewWatcher.mock.funcNewWatcher = f
	mmNewWatcher.mock.funcNewWatcherOrigin = minimock.CallerInfo(1)
	return mmNewWatcher.mock
}

// When sets expectation for the DoerWatcher.NewWatcher which will trigger the result defined by the following
// Then helper
func (mmNewWatcher *mDoerWatcherMockNewWatcher) When(key string, callback tarantool.WatchCallback) *DoerWatcherMockNewWatcherExpectation {
	if mmNewWatcher.mock.funcNewWatcher != nil {
		mmNewWatcher.mock.t.Fatalf("DoerWatcherMock.NewWatcher mock is already set by Set")
	}

	expectation := &DoerWatcherMockNewWatcherExpectation{
		mock:               mmNewWatcher.mock,
		params:             &DoerWatcherMockNewWatcherParams{key, callback},
		expectationOrigins: DoerWatcherMockNewWatcherExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmNewWatcher.expectations = append(mmNewWatcher.expectations, expectation)
	return expectation
}

// Then sets up DoerWatcher.NewWatcher return parameters for the expectation previously defined by the When method
func (e *DoerWatcherMockNewWatcherExpectation) Then(w1 tarantool.Watcher, err error) *DoerWatcherMock {
	e.results = &DoerWatcherMockNewWatcherResults{w1, err}
	return e.mock
}

// Times sets number of times DoerWatcher.NewWatcher should be invoked
func (mmNewWatcher *mDoerWatcherMockNewWatcher) Times(n uint64) *mDoerWatcherMockNewWatcher {
	if n == 0 {
		mmNewWatcher.mock.t.Fatalf("Times of DoerWatcherMock.NewWatcher mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmNewWatcher.expectedInvocations, n)
	mmNewWatcher.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmNewWatcher
}

func (mmNewWatcher *mDoerWatcherMockNewWatcher) invocationsDone() bool {
	if len(mmNewWatcher.expectations) == 0 && mmNewWatcher.defaultExpectation == nil && mmNewWatcher.mock.funcNewWatcher == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmNewWatcher.mock.afterNewWatcherCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmNewWatcher.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// NewWatcher implements mm_tcs.DoerWatcher
func (mmNewWatcher *DoerWatcherMock) NewWatcher(key string, callback tarantool.WatchCallback) (w1 tarantool.Watcher, err error) {
	mm_atomic.AddUint64(&mmNewWatcher.beforeNewWatcherCounter, 1)
	defer mm_atomic.AddUint64(&mmNewWatcher.afterNewWatcherCounter, 1)

	mmNewWatcher.t.Helper()

	if mmNewWatcher.inspectFuncNewWatcher != nil {
		mmNewWatcher.inspectFuncNewWatcher(key, callback)
	}

	mm_params := DoerWatcherMockNewWatcherParams{key, callback}

	// Record call args
	mmNewWatcher.NewWatcherMock.mutex.Lock()
	mmNewWatcher.NewWatcherMock.callArgs = append(mmNewWatcher.NewWatcherMock.callArgs, &mm_params)
	mmNewWatcher.NewWatcherMock.mutex.Unlock()

	for _, e := range mmNewWatcher.NewWatcherMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.w1, e.results.err
		}
	}

	if mmNewWatcher.NewWatcherMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNewWatcher.NewWatcherMock.defaultExpectation.Counter, 1)
		mm_want := mmNewWatcher.NewWatcherMock.defaultExpectation.params
		mm_want_ptrs := mmNewWatcher.NewWatcherMock.defaultExpectation.paramPtrs

		mm_got := DoerWatcherMockNewWatcherParams{key, callback}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmNewWatcher.t.Errorf("DoerWatcherMock.NewWatcher got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmNewWatcher.NewWatcherMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.callback != nil && !minimock.Equal(*mm_want_ptrs.callback, mm_got.callback) {
				mmNewWatcher.t.Errorf("DoerWatcherMock.NewWatcher got unexpected parameter callback, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmNewWatcher.NewWatcherMock.defaultExpectation.expectationOrigins.originCallback, *mm_want_ptrs.callback, mm_got.callback, minimock.Diff(*mm_want_ptrs.callback, mm_got.callback))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmNewWatcher.t.Errorf("DoerWatcherMock.NewWatcher got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmNewWatcher.NewWatcherMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmNewWatcher.NewWatcherMock.defaultExpectation.results
		if mm_results == nil {
			mmNewWatcher.t.Fatal("No results are set for the DoerWatcherMock.NewWatcher")
		}
		return (*mm_results).w1, (*mm_results).err
	}
	if mmNewWatcher.funcNewWatcher != nil {
		return mmNewWatcher.funcNewWatcher(key, callback)
	}
	mmNewWatcher.t.Fatalf("Unexpected call to DoerWatcherMock.NewWatcher. %v %v", key, callback)
	return
}

// NewWatcherAfterCounter returns a count of finished DoerWatcherMock.NewWatcher invocations
func (mmNewWatcher *DoerWatcherMock) NewWatcherAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewWatcher.afterNewWatcherCounter)
}

// NewWatcherBeforeCounter returns a count of DoerWatcherMock.NewWatcher invocations
func (mmNewWatcher *DoerWatcherMock) NewWatcherBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewWatcher.beforeNewWatcherCounter)
}

// Calls returns a list of arguments used in each call to DoerWatcherMock.NewWatcher.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmNewWatcher *mDoerWatcherMockNewWatcher) Calls() []*DoerWatcherMockNewWatcherParams {
	mmNewWatcher.mutex.RLock()

	argCopy := make([]*DoerWatcherMockNewWatcherParams, len(mmNewWatcher.callArgs))
	copy(argCopy, mmNewWatcher.callArgs)

	mmNewWatcher.mutex.RUnlock()

	return argCopy
}

// MinimockNewWatcherDone returns true if the count of the NewWatcher invocations corresponds
// the number of defined expectations
func (m *DoerWatcherMock) MinimockNewWatcherDone() bool {
	if m.NewWatcherMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.NewWatcherMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.NewWatcherMock.invocationsDone()
}

// MinimockNewWatcherInspect logs each unmet expectation
func (m *DoerWatcherMock) MinimockNewWatcherInspect() {
	for _, e := range m.NewWatcherMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DoerWatcherMock.NewWatcher at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterNewWatcherCounter := mm_atomic.LoadUint64(&m.afterNewWatcherCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.NewWatcherMock.defaultExpectation != nil && afterNewWatcherCounter < 1 {
		if m.NewWatcherMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DoerWatcherMock.NewWatcher at\n%s", m.NewWatcherMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DoerWatcherMock.NewWatcher at\n%s with params: %#v", m.NewWatcherMock.defaultExpectation.expectationOrigins.origin, *m.NewWatcherMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewWatcher != nil && afterNewWatcherCounter < 1 {
		m.t.Errorf("Expected call to DoerWatcherMock.NewWatcher at\n%s", m.funcNewWatcherOrigin)
	}

	if !m.NewWatcherMock.invocationsDone() && afterNewWatcherCounter > 0 {
		m.t.Errorf("Expected %d calls to DoerWatcherMock.NewWatcher at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.NewWatcherMock.expectedInvocations), m.NewWatcherMock.expectedInvocationsOrigin, afterNewWatcherCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *DoerWatcherMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDoInspect()

			m.MinimockNewWatcherInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *DoerWatcherMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *DoerWatcherMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDoDone() &&
		m.MinimockNewWatcherDone()
}
